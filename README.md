# Personio : organization-board
REST API FOR ORGANIZATION TEAM STRUCTURE/HIERARCHY MANAGMENT

## Getting Started

### Requirements :
```
* GO 1.14
```
Install GO from [here](https://golang.org/dl/) <br/>
All other required dependancies are already part of the project.

### Run Test Cases
```
./tests.sh
```
### Run The project
Script builds GO binary and runs the binary.
```
./run.sh
```

## Application Design

### High Level Design :
The project is divided into two main module.<br/>
1. Query Parser : Tokenizes and parses CSV query into internal representation.
2. Query Executor : Consumes Query generated by parser and returns result of the query execution

#### Query Parser :
* Query parser is implemented as state machine as depicted in the picture below.
* The parser FSM(finite state machine) has "FROM/JOIN/COUNTBY/ORDERBY/TAKE/SELECT" as valid states.
* It starts with the parsing of `FROM` state and prceeeds through the other states.
* Each state except `FROM` is optional and if present parser makes sure the input fields required at each state are parsed as well. <br/>Eg: Two CSV files and a column for `JOIN` state
* The ordering of the states is ensured by default. So one can not enter `SELECT` after `TAKE`.<br/> `"FROM abc.CSV SELECT column1 TAKE 10"` is invalid.
* Parse also makes sure input validations are performed such as:<br/>
<pre>
  1. Query is not empty and does not contain any gibbereish or non-parseable tokens.
  2. FROM    : At least one CSV file is specified.
  3. JOIN    : Two CSV files with a join-key are specified.
  4. COUNTBY : Column is specified for aggregation.
  5. ORDERBY : column is specified for sorting in descending order.
  6. TAKE    : Valid integer value is specifie to limit the output size.
  7. SELECT  : Column/columns are specified for filtering.
</pre>

![alt text](Query-FSM.jpg "Query FSM")

#### Query Executor :
* Query executor is designed as the pipeline of higher order functions to lower functions on input data and the internal Query represntation generated by the Query Parser.
* It reads colums keys and data rows from first file and then executes `JOIN->COUNTBY->ORDERBY->TAKE->SELECT` functions sequnetially of course depending on what is being asked in the query :).
* Execution result of each function is cached and then fed into next function with final output returned as the query result.
* It supports two variations for performing join - a simple join and a Sort Merge Join.
* Executor also handles any errors encountered during query execution and returns them to the client such as
<pre>
  1. All CSV files specified in the query, do exist, are not empty and there are valid permissions to access them.
  2. JOIN    : Join coulmn is present in CSV files.
  3. COUNTBY : Countby column is present.
  4. ORDERBY : Orderby column is present and entire column data is in integer format.
  5. TAKE    : Negative values, zero value or values more than data size are handled.
  6. SELECT  : Select Column/columns are present.
</pre>
#### File Operations :
A wrapper over GO's CSV file operation APIs.
#### Custom Errors :
A detailed list of errors covering query input, parsing and execution phase.
#### Util :
Provies print functionality for errors and query output.
Query output is printed in either `CSV` or `Tabular` format.
#### Testing :
Each module mentioned above, has extensive test coverage and each code file is accompnied by the corresponding test file.


## Assumptions
1. Simple JOIN algorithm : It only takes first match from second file and proceeds further.
```
For each row in first CSV file :
  For each row in Second CSV file :
    if join-key has same value for both the rows :
      - new_row = row from CSV1 + row from CSV2
      - Add new_row to the ouput
      - Break and proceed to next row in first CSV file
```
2. Query parser is writted as FSM of commands FROM->JOIN->COUNTBY->ORDERBY->TAKE->SELECT. So though not specified in problem definition, "JOIN" can be followed by "ORDERBY', "TAKE" etc.
3. TAKE value of zero is treated as not specified , so all the rows will be returned.

## Improvement Ideas
* BDD frameworks [Gingko](https://onsi.github.io/ginkgo/), [Gomega](https://onsi.github.io/gomega/) can be used for more expressive test cases.
* Scale/Perf run the app with [pprof](https://blog.golang.org/pprof) to find out any cpu, memory, performance bottlenecks.
* Improve metric, tracing and logging of app. Use [zap](https://github.com/uber-go/zap)
* All the errors can be numbered to build full fledged documentation around it.

## LOGIN CURL REQUEST
curl -v -d '{"email": "personia@org.com", "password": "personia"}' -H 'Content-Type: application/json' http://localhost:9090/api/v1/login?
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 9090 (#0)
> POST /api/v1/login? HTTP/1.1
> Host: localhost:9090
> User-Agent: curl/7.64.1
> Accept: */*
> Content-Type: application/json
> Content-Length: 53
>
* upload completely sent off: 53 out of 53 bytes
< HTTP/1.1 200 OK
< Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJlbWFpbCI6InBlcnNvbmlhQG9yZy5jb20ifX0._w2Ksdm7sOxiAHJw61ZR1X7aldRLa564wK-9e5O9f-c
< Content-Type: application/json
< Date: Sat, 12 Sep 2020 17:26:42 GMT
< Content-Length: 57
<
* Connection #0 to host localhost left intact
{"status":200,"data":{"id":1,"email":"personia@org.com"}}* Closing connection 0
